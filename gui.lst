ca65 V2.13.3 - (C) Copyright 1998-2012 Ullrich von Bassewitz
Main file   : gui.s
Current file: gui.s

000000r 1               ;
000000r 1               ;  gui.s
000000r 1               ;  AssemblyTest
000000r 1               ;
000000r 1               ;  Created by Quinn Dunki on 8/15/14.
000000r 1               ;  Copyright (c) 2014 One Girl, One Laptop Productions. All rights reserved.
000000r 1               ;
000000r 1               
000000r 1               
000000r 1               .org $4000
004000  1               
004000  1               
004000  1               ; Common definitions
004000  1               
004000  1               .include "switches.s"
004000  2               ;
004000  2               ;  switches.s
004000  2               ;  Softswitches for Apple ][
004000  2               ;
004000  2               ;  Created by Quinn Dunki on 8/15/14.
004000  2               ;  Copyright (c) 2014 One Girl, One Laptop Productions. All rights reserved.
004000  2               ;
004000  2               
004000  2               
004000  2               PAGE2			= $c01c ; Read bit 7
004000  2               PAGE2OFF		= $c054 ; Read/Write
004000  2               PAGE2ON			= $c055 ; Read/Write
004000  2               
004000  2               COL80			= $c01f	; Read bit 7
004000  2               COL80OFF		= $c00c	; Write
004000  2               COL80ON			= $c00d ; Write
004000  2               
004000  2               STORE80			= $c018	; Read bit 7
004000  2               STORE80OFF		= $c000 ; Write
004000  2               STORE80ON		= $c001 ; Write
004000  2               
004000  2               TEXT			= $c01a ; Read bit 7
004000  2               TEXTOFF			= $c050 ; Read/Write
004000  2               TEXTON			= $C051 ; Read/Write
004000  2               
004000  2               KBD				= $c000 ; Read
004000  2               KBDSTRB			= $c010	; Read/Write
004000  2               
004000  2               RDVBLBAR		= $C019	; Read bit 7 (active low)
004000  2               
004000  1               .include "macros.s"
004000  2               ;
004000  2               ;  macros.s
004000  2               ;  Generally useful macros for 6502 code
004000  2               ;
004000  2               ;  Created by Quinn Dunki on 8/15/14.
004000  2               ;  Copyright (c) 2014 One Girl, One Laptop Productions. All rights reserved.
004000  2               ;
004000  2               
004000  2               
004000  2               ; Macros
004000  2               
004000  2               .macro SETSWITCH name		; Sets the named softswitch (assumes write method)
004000  2               	sta name
004000  2               .endmacro
004000  2               
004000  2               
004000  2               .macro SAVE_AXY				; Saves all registers
004000  2               	pha
004000  2               	txa
004000  2               	pha
004000  2               	tya
004000  2               	pha
004000  2               .endmacro
004000  2               
004000  2               
004000  2               .macro RESTORE_AXY			; Restores all registers
004000  2               	pla
004000  2               	tay
004000  2               	pla
004000  2               	tax
004000  2               	pla
004000  2               .endmacro
004000  2               
004000  2               
004000  2               .macro SAVE_AY				; Saves accumulator and Y index
004000  2               	pha
004000  2               	tya
004000  2               	pha
004000  2               .endmacro
004000  2               
004000  2               
004000  2               .macro RESTORE_AY			; Restores accumulator and Y index
004000  2               	pla
004000  2               	tay
004000  2               	pla
004000  2               .endmacro
004000  2               
004000  2               
004000  2               .macro SAVE_AX				; Saves accumulator and X index
004000  2               	pha
004000  2               	txa
004000  2               	pha
004000  2               .endmacro
004000  2               
004000  2               
004000  2               .macro RESTORE_AX			; Restores accumulator and X index
004000  2               	pla
004000  2               	tax
004000  2               	pla
004000  2               .endmacro
004000  2               
004000  2               
004000  2               .macro SAVE_ZPP				; Saves Zero Page locations we use for parameters
004000  2               	lda	PARAM0
004000  2               	pha
004000  2               	lda PARAM1
004000  2               	pha
004000  2               	lda PARAM2
004000  2               	pha
004000  2               	lda PARAM3
004000  2               	pha
004000  2               .endmacro
004000  2               
004000  2               
004000  2               .macro RESTORE_ZPP			; Restores Zero Page locations we use for parameters
004000  2               	pla
004000  2               	sta PARAM3
004000  2               	pla
004000  2               	sta PARAM2
004000  2               	pla
004000  2               	sta PARAM1
004000  2               	pla
004000  2               	sta PARAM0
004000  2               .endmacro
004000  2               
004000  2               
004000  2               .macro SAVE_ZPS				; Saves Zero Page locations we use for scratch
004000  2               	lda	SCRATCH0
004000  2               	pha
004000  2               	lda SCRATCH1
004000  2               	pha
004000  2               .endmacro
004000  2               
004000  2               
004000  2               .macro RESTORE_ZPS			; Restores Zero Page locations we use for scratch
004000  2               	pla
004000  2               	sta	SCRATCH1
004000  2               	pla
004000  2               	sta	SCRATCH0
004000  2               .endmacro
004000  2               
004000  2               
004000  2               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
004000  2               ; Rendering macros
004000  2               ;
004000  2               
004000  2               .macro LDY_ACTIVEVIEW
004000  2               	lda WG_ACTIVEVIEW	; Find our new view record
004000  2               	and #%00001111
004000  2               	asl
004000  2               	asl
004000  2               	asl
004000  2               	asl
004000  2               	asl
004000  2               	asl
004000  2               	asl
004000  2               	asl				; Records are 16 bytes wide
004000  2               	tay
004000  2               .endmacro
004000  2               
004000  2               
004000  2               .macro LDX_ACTIVEVIEW
004000  2               	lda WG_ACTIVEVIEW	; Find our new view record
004000  2               	and #%00001111
004000  2               	asl
004000  2               	asl
004000  2               	asl
004000  2               	asl
004000  2               	asl
004000  2               	asl
004000  2               	asl
004000  2               	asl				; Records are 16 bytes wide
004000  2               	tax
004000  2               .endmacro
004000  2               
004000  2               
004000  2               .macro VBL_SYNC				; Synchronize with vertical blanking
004000  2               	lda #$80
004000  2               macroWaitVBLToFinish:
004000  2               	bit	RDVBLBAR
004000  2               	bmi	tortureTestRectsWaitVBLToFinish
004000  2               macroWaitVBLToStart:
004000  2               	bit	RDVBLBAR
004000  2               	bpl	tortureTestRectsWaitVBLToStart
004000  2               .endmacro
004000  2               
004000  1               
004000  1               
004000  1               ; Main
004000  1               
004000  1               main:
004000  1  20 3D 40     	jsr begin80cols
004003  1  20 CA 40     	jsr WGClearScreen
004006  1               
004006  1  A9 50        	lda	#<testView
004008  1  8D 06 00     	sta	PARAM0
00400B  1  A9 48        	lda	#>testView
00400D  1  8D 07 00     	sta	PARAM1
004010  1  20 05 45     	jsr	WGCreateView
004013  1               
004013  1  A9 00        	lda #0
004015  1  20 BE 45     	jsr	WGSelectView
004018  1               
004018  1  20 6B 45     	jsr	WGPaintView
00401B  1               
00401B  1  A2 05        	ldx	#5
00401D  1  A0 00        	ldy	#0
00401F  1  20 D7 45     	jsr	WGSetCursor
004022  1               
004022  1  A9 00        	lda	#0
004024  1  20 28 46     	jsr	WGScrollX
004027  1  A9 FE        	lda	#-2
004029  1  20 4A 46     	jsr	WGScrollY
00402C  1               
00402C  1               ;	lda WG_VIEWCLIP+0
00402C  1               ;	jsr PRBYTE
00402C  1               ;	lda WG_VIEWCLIP+1
00402C  1               ;	jsr PRBYTE
00402C  1               ;	lda WG_VIEWCLIP+2
00402C  1               ;	jsr PRBYTE
00402C  1               ;	lda WG_VIEWCLIP+3
00402C  1               ;	jsr PRBYTE
00402C  1               ;	lda WG_VIEWCLIP+4
00402C  1               ;	jsr PRBYTE
00402C  1               
00402C  1               ;	lda WG_VIEWRECORDS+0
00402C  1               ;	jsr PRBYTE
00402C  1               ;	lda WG_VIEWRECORDS+1
00402C  1               ;	jsr PRBYTE
00402C  1               ;	lda WG_VIEWRECORDS+2
00402C  1               ;	jsr PRBYTE
00402C  1               ;	lda WG_VIEWRECORDS+3
00402C  1               ;	jsr PRBYTE
00402C  1               ;	lda WG_VIEWRECORDS+4
00402C  1               ;	jsr PRBYTE
00402C  1               ;	lda WG_VIEWRECORDS+5
00402C  1               ;	jsr PRBYTE
00402C  1               ;	lda WG_VIEWRECORDS+6
00402C  1               ;	jsr PRBYTE
00402C  1               ;	lda WG_VIEWRECORDS+7
00402C  1               ;	jsr PRBYTE
00402C  1               ;	lda WG_VIEWRECORDS+8
00402C  1               ;	jsr PRBYTE
00402C  1               
00402C  1  A9 5E        	lda	#<testStr
00402E  1  8D 06 00     	sta	PARAM0
004031  1  A9 48        	lda #>testStr
004033  1  8D 07 00     	sta PARAM1
004036  1  20 1C 44     	jsr WGPrint
004039  1               
004039  1               ;	lda	#1
004039  1               ;	sta PARAM0
004039  1               ;	lda	#1
004039  1               ;	sta	PARAM1
004039  1               ;	lda #2
004039  1               ;	sta	PARAM2
004039  1               ;	lda	#2
004039  1               ;	sta	PARAM3
004039  1               ;	ldx	#'Q'+$80
004039  1               ;	jsr	WGFillRect
004039  1               ;	jsr	WGStrokeRect
004039  1               ;	jmp loop
004039  1               ;	jsr	waitForKey
004039  1               
004039  1               ;	jmp tortureTestRects
004039  1               
004039  1               loop:
004039  1               ;	lda	#'Q' + $80
004039  1               ;	jsr	COUT
004039  1  4C 39 40     	jmp loop
00403C  1  60           	rts			; This seems to work for returning to BASIC.SYSTEM, but I don't think it's right
00403D  1               
00403D  1               
00403D  1               
00403D  1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00403D  1               ; begin80cols
00403D  1               ; Enables 80 column mode (and enhanced video firmware)
00403D  1               begin80cols:
00403D  1  A9 A0        	lda	#$a0
00403F  1  20 00 C3     	jsr	$c300
004042  1  8D 51 C0     	SETSWITCH	TEXTON
004045  1  8D 54 C0     	SETSWITCH	PAGE2OFF
004048  1  8D 0D C0     	SETSWITCH	COL80ON
00404B  1  8D 01 C0     	SETSWITCH	STORE80ON
00404E  1  60           	rts
00404F  1               
00404F  1               
00404F  1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00404F  1               ; waitForKey
00404F  1               ; Spinlocks until a key is pressed
00404F  1               waitForKey:
00404F  1  AD 10 C0     	lda	KBDSTRB
004052  1  10 FB        	bpl waitForKey
004054  1  60           	rts
004055  1               
004055  1               
004055  1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
004055  1               ; read80ColSwitch
004055  1               ; Returns value of the 80 col switch on //c and //c+ machines
004055  1               ; OUT A: Switch state (non-zero=80 cols)
004055  1               ; NOTE: Untested
004055  1               read80ColSwitch:
004055  1  AD 60 C0     	lda $c060
004058  1  10 03        	bpl read80ColSwitch_40
00405A  1  A9 01        	lda #$1
00405C  1  60           	rts
00405D  1               
00405D  1               read80ColSwitch_40:
00405D  1  A9 00        	lda #$0
00405F  1  60           	rts
004060  1               
004060  1               
004060  1               ; Code modules
004060  1               .include "utility.s"
004060  2               ;
004060  2               ;  utility.s
004060  2               ;  General utilities for 6502
004060  2               ;
004060  2               ;  Created by Quinn Dunki on 8/15/14.
004060  2               ;  Copyright (c) 2014 One Girl, One Laptop Productions. All rights reserved.
004060  2               ;
004060  2               
004060  2               
004060  2               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
004060  2               ; delay
004060  2               ; Sleeps for ~1 second
004060  2               ;
004060  2               delay:
004060  2  48 8A 48 98  	SAVE_AXY
004064  2  48           
004065  2               
004065  2  A0 CE        	ldy		#$ce	; Loop a bunch
004067  2               delayOuter:
004067  2  A2 FF        	ldx		#$ff
004069  2               delayInner:
004069  2  EA           	nop
00406A  2  EA           	nop
00406B  2  EA           	nop
00406C  2  EA           	nop
00406D  2  EA           	nop
00406E  2  EA           	nop
00406F  2  EA           	nop
004070  2  CA           	dex
004071  2  D0 F6        	bne		delayInner
004073  2  88           	dey
004074  2  D0 F1        	bne		delayOuter
004076  2               
004076  2  68 A8 68 AA  	RESTORE_AXY
00407A  2  68           
00407B  2  60           	rts
00407C  2               
00407C  2               
00407C  2               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00407C  2               ; delayShort
00407C  2               ; Sleeps for ~1/30th second
00407C  2               ;
00407C  2               delayShort:
00407C  2  48 8A 48 98  	SAVE_AXY
004080  2  48           
004081  2               
004081  2  A0 06        	ldy		#$06	; Loop a bit
004083  2               delayShortOuter:
004083  2  A2 FF        	ldx		#$ff
004085  2               delayShortInner:
004085  2  EA           	nop
004086  2  EA           	nop
004087  2  EA           	nop
004088  2  EA           	nop
004089  2  EA           	nop
00408A  2  EA           	nop
00408B  2  EA           	nop
00408C  2  CA           	dex
00408D  2  D0 F6        	bne		delayShortInner
00408F  2  88           	dey
004090  2  D0 F1        	bne		delayShortOuter
004092  2               
004092  2  68 A8 68 AA  	RESTORE_AXY
004096  2  68           
004097  2  60           	rts
004098  2               
004098  2               
004098  2               ;;;;;;;;;;;;;;;;;;;;;;;
004098  2               ; scanHexDigit
004098  2               ; Scans a 4 bit hex value from an ASCII character
004098  2               ; A: ASCII character
004098  2               ; Out A: Hex value
004098  2               ;
004098  2               scanHexDigit:
004098  2  C9 41        	cmp		#'A'
00409A  2  B0 06        	bcs		scanHexDigitLetter
00409C  2  38           	sec
00409D  2  E9 30        	sbc		#'0'
00409F  2  4C A5 40     	jmp		scanHexDigitDone
0040A2  2               
0040A2  2               scanHexDigitLetter:
0040A2  2  38           	sec
0040A3  2  E9 37        	sbc		#55
0040A5  2               
0040A5  2               scanHexDigitDone:
0040A5  2  60           	rts
0040A6  2               
0040A6  2               
0040A6  2               ;;;;;;;;;;;;;;;;;;;;;;;
0040A6  2               ; scanHex8
0040A6  2               ; Scans an 8 bit hex value from a string
0040A6  2               ; PARAM0: Pointer to string (LSB)
0040A6  2               ; PARAM1: Pointer to string (MSB)
0040A6  2               ; Y: Offset into string
0040A6  2               ; Out A: 8-bit hex value
0040A6  2               ; Side effects: Clobbers Y and S0
0040A6  2               ;
0040A6  2               scanHex8:
0040A6  2  B1 06        	lda		(PARAM0),y
0040A8  2  20 98 40     	jsr		scanHexDigit
0040AB  2  0A           	asl
0040AC  2  0A           	asl
0040AD  2  0A           	asl
0040AE  2  0A           	asl
0040AF  2  8D 19 00     	sta		SCRATCH0		; Stash first digit for later
0040B2  2               
0040B2  2  C8           	iny
0040B3  2  B1 06        	lda		(PARAM0),y
0040B5  2  20 98 40     	jsr		scanHexDigit
0040B8  2  0D 19 00     	ora		SCRATCH0
0040BB  2  C8           	iny						; Be nice and advance Y to end
0040BC  2  60           	rts
0040BD  2               
0040BD  2               
0040BD  2               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040BD  2               ; WGStrLen
0040BD  2               ; Finds the length of a null-terminated string
0040BD  2               ; PARAM0: String pointer, LSB
0040BD  2               ; PARAM1: String pointer, MSB
0040BD  2               ; Return: A: String length, not including null
0040BD  2               ;
0040BD  2               WGStrLen:
0040BD  2  5A           	phy
0040BE  2               
0040BE  2  A0 00        	ldy #$0
0040C0  2               WGStrLen_loop:
0040C0  2  B1 06        	lda	(PARAM0),y
0040C2  2  F0 03        	beq	WGStrLen_done
0040C4  2  C8           	iny
0040C5  2  80 F9        	bra	WGStrLen_loop
0040C7  2               
0040C7  2               WGStrLen_done:
0040C7  2  98           	tya
0040C8  2  7A           	ply
0040C9  2  60           	rts
0040CA  2               
0040CA  2               
0040CA  2               
0040CA  1               .include "painting.s"
0040CA  2               ;
0040CA  2               ;  painting.s
0040CA  2               ;  Rendering routines for 80 column text elements
0040CA  2               ;
0040CA  2               ;  Created by Quinn Dunki on 8/15/14.
0040CA  2               ;  Copyright (c) 2014 One Girl, One Laptop Productions. All rights reserved.
0040CA  2               ;
0040CA  2               
0040CA  2               
0040CA  2               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040CA  2               ; WGClearScreen
0040CA  2               ; Clears the text screen (assumes 80 cols)
0040CA  2               ; Side effects: Clobbers BASL,BASH
0040CA  2               ;
0040CA  2               WGClearScreen:
0040CA  2               
0040CA  2  48 8A 48 98  	SAVE_AXY
0040CE  2  48           
0040CF  2  8D 54 C0     	SETSWITCH	PAGE2OFF
0040D2  2  A2 17        	ldx	#23
0040D4  2               
0040D4  2               WGClearScreen_lineLoop:
0040D4  2               
0040D4  2  BD 38 48     	lda TEXTLINES_L,x	; Compute video memory address of line
0040D7  2  8D 28 00     	sta BASL
0040DA  2  BD 20 48     	lda TEXTLINES_H,x
0040DD  2  8D 29 00     	sta BASH
0040E0  2               
0040E0  2  A0 27        	ldy	#39
0040E2  2  A9 A0        	lda	#' ' + $80
0040E4  2               
0040E4  2               WGClearScreen_charLoop:
0040E4  2  91 28        	sta	(BASL),y
0040E6  2  8D 55 C0     	SETSWITCH	PAGE2ON
0040E9  2  91 28        	sta	(BASL),y
0040EB  2  8D 54 C0     	SETSWITCH	PAGE2OFF
0040EE  2  88           	dey
0040EF  2  10 F3        	bpl	WGClearScreen_charLoop
0040F1  2               
0040F1  2  CA           	dex
0040F2  2  10 E0        	bpl WGClearScreen_lineLoop
0040F4  2               
0040F4  2  68 A8 68 AA  	RESTORE_AXY
0040F8  2  68           
0040F9  2  60           	rts
0040FA  2               
0040FA  2               
0040FA  2               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040FA  2               ; WGFillRect
0040FA  2               ; Fills a rectangle (assumes 80 cols)
0040FA  2               ; PARAM0: Left edge
0040FA  2               ; PARAM1: Top edge
0040FA  2               ; PARAM2: Width
0040FA  2               ; PARAM3: Height
0040FA  2               ; X: Character to fill
0040FA  2               ; Side effects: Clobbers BASL,BASH
0040FA  2               ;
0040FA  2               WGFillRect:
0040FA  2               
0040FA  2  48 8A 48 98  	SAVE_AXY
0040FE  2  48           
0040FF  2  AD 19 00 48  	SAVE_ZPS
004103  2  AD 1A 00 48  
004107  2  8E 19 00     	stx	SCRATCH0
00410A  2               
00410A  2  18           	clc					; Compute bottom edge
00410B  2  AD 07 00     	lda	PARAM1
00410E  2  6D 09 00     	adc PARAM3
004111  2  AA           	tax
004112  2               
004112  2               WGFillRect_vertLoop:
004112  2  DA           	phx					; We'll need X back for now, but save the line number
004113  2               
004113  2  BD 38 48     	lda TEXTLINES_L,x	; Compute video memory address of left edge of rect
004116  2  8D 28 00     	sta BASL
004119  2  BD 20 48     	lda TEXTLINES_H,x
00411C  2  8D 29 00     	sta BASH
00411F  2               
00411F  2  AD 06 00     	lda	PARAM0
004122  2  4A           	lsr
004123  2  18           	clc
004124  2  6D 28 00     	adc	BASL
004127  2  8D 28 00     	sta BASL
00412A  2  A9 00        	lda	#$0
00412C  2  6D 29 00     	adc BASH
00412F  2  8D 29 00     	sta BASH
004132  2               
004132  2  AD 06 00     	lda	PARAM0			; Left edge even?
004135  2  29 01        	and	#$01
004137  2  D0 39        	bne	WGFillRect_horzLoopOdd
004139  2               
004139  2               	; CASE 1: Left edge even-aligned, even width
004139  2  8D 54 C0     	SETSWITCH	PAGE2OFF
00413C  2  AD 08 00     	lda	PARAM2
00413F  2  4A           	lsr
004140  2  A8           	tay					; Iterate w/2
004141  2  88           	dey
004142  2  5A           	phy					; We'll reuse this calculation for the odd columns
004143  2               
004143  2               WGFillRect_horzLoopEvenAligned0:	; Draw even columns
004143  2  AD 19 00     	lda	SCRATCH0					; Plot the character
004146  2  91 28        	sta	(BASL),y
004148  2  88           	dey
004149  2  10 F8        	bpl	WGFillRect_horzLoopEvenAligned0	; Loop for w/2
00414B  2               
00414B  2  8D 55 C0     	SETSWITCH	PAGE2ON				; Prepare for odd columns
00414E  2  7A           	ply								; Iterate w/2 again
00414F  2               
00414F  2               WGFillRect_horzLoopEvenAligned1:	; Draw odd columns
00414F  2  AD 19 00     	lda	SCRATCH0					; Plot the character
004152  2  91 28        	sta	(BASL),y
004154  2  88           	dey
004155  2  10 F8        	bpl	WGFillRect_horzLoopEvenAligned1	; Loop for w/2
004157  2               
004157  2  AD 08 00     	lda	PARAM2						; Is width even?
00415A  2  29 01        	and	#$01
00415C  2  F0 0A        	beq	WGFillRect_horzLoopEvenAlignedEvenWidth
00415E  2               
00415E  2               	; CASE 1a: Left edge even aligned, odd width
00415E  2  AD 08 00     	lda	PARAM2						; Fill in extra last column
004161  2  4A           	lsr
004162  2  A8           	tay
004163  2  AD 19 00     	lda	SCRATCH0					; Plot the character
004166  2  91 28        	sta	(BASL),y
004168  2               
004168  2               WGFillRect_horzLoopEvenAlignedEvenWidth:
004168  2  FA           	plx								; Prepare for next row
004169  2  CA           	dex
00416A  2  EC 07 00     	cpx	PARAM1
00416D  2  B0 A3        	bcs	WGFillRect_vertLoop
00416F  2  4C AE 41     	jmp	WGFillRect_done
004172  2               
004172  2               WGFillRect_horzLoopOdd:
004172  2               	; CASE 2: Left edge odd-aligned, even width
004172  2  8D 55 C0     	SETSWITCH	PAGE2ON
004175  2  AD 08 00     	lda	PARAM2
004178  2  4A           	lsr
004179  2  A8           	tay					; Iterate w/2
00417A  2  5A           	phy					; We'll reuse this calculation for the even columns
00417B  2               
00417B  2               WGFillRect_horzLoopOddAligned0:		; Draw even columns
00417B  2  AD 19 00     	lda	SCRATCH0					; Plot the character
00417E  2  91 28        	sta	(BASL),y
004180  2  88           	dey
004181  2  D0 F8        	bne	WGFillRect_horzLoopOddAligned0	; Loop for w/2
004183  2               
004183  2  8D 54 C0     	SETSWITCH	PAGE2OFF				; Prepare for odd columns
004186  2  7A           	ply									; Iterate w/2 again, shift left 1
004187  2  88           	dey
004188  2               
004188  2               WGFillRect_horzLoopOddAligned1:		; Draw even columns
004188  2  AD 19 00     	lda	SCRATCH0					; Plot the character
00418B  2  91 28        	sta	(BASL),y
00418D  2  88           	dey
00418E  2  10 F8        	bpl	WGFillRect_horzLoopOddAligned1	; Loop for w/2
004190  2               
004190  2  AD 08 00     	lda	PARAM2						; Is width even?
004193  2  29 01        	and	#$01
004195  2  F0 0A        	beq	WGFillRect_horzLoopOddAlignedEvenWidth
004197  2               
004197  2               	; CASE 2a: Left edge odd aligned, odd width
004197  2  AD 08 00     	lda	PARAM2						; Fill in extra last column
00419A  2  4A           	lsr
00419B  2  A8           	tay
00419C  2  AD 19 00     	lda	SCRATCH0					; Plot the character
00419F  2  91 28        	sta	(BASL),y
0041A1  2               
0041A1  2               WGFillRect_horzLoopOddAlignedEvenWidth:
0041A1  2  FA           	plx								; Prepare for next row
0041A2  2  CA           	dex
0041A3  2  EC 07 00     	cpx	PARAM1
0041A6  2  B0 03        	bcs	WGFillRect_vertLoopJmp
0041A8  2  4C AE 41     	jmp WGFillRect_done
0041AB  2               WGFillRect_vertLoopJmp:
0041AB  2  4C 12 41     	jmp	WGFillRect_vertLoop
0041AE  2               
0041AE  2               WGFillRect_done:
0041AE  2  68 8D 1A 00  	RESTORE_ZPS
0041B2  2  68 8D 19 00  
0041B6  2  68 A8 68 AA  	RESTORE_AXY
0041BA  2  68           
0041BB  2  60           	rts
0041BC  2               
0041BC  2               
0041BC  2               
0041BC  2               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0041BC  2               ; WGStrokeRect
0041BC  2               ; Strokes a rectangle (assumes 80 cols)
0041BC  2               ; PARAM0: Left edge
0041BC  2               ; PARAM1: Top edge
0041BC  2               ; PARAM2: Width
0041BC  2               ; PARAM3: Height
0041BC  2               ; Side effects: Clobbers BASL,BASH
0041BC  2               ;
0041BC  2               CH_TOP = '_'+$80
0041BC  2               CH_BOTTOM = 'L';'_'+$80
0041BC  2               CH_LEFT = 'Z';'_'+$80
0041BC  2               CH_RIGHT = '_'
0041BC  2               CH_BOTTOMLEFT = 'L'
0041BC  2               CH_BOTTOMRIGHT = '_'+$80
0041BC  2               
0041BC  2               WGStrokeRect:
0041BC  2               
0041BC  2  48 8A 48 98  	SAVE_AXY
0041C0  2  48           
0041C1  2  AD 19 00 48  	SAVE_ZPS
0041C5  2  AD 1A 00 48  
0041C9  2               
0041C9  2               	; Top and bottom edges
0041C9  2               	;
0041C9  2  AE 07 00     	ldx	PARAM1			; Start with top edge
0041CC  2  CA           	dex
0041CD  2  A9 DF        	lda	#CH_TOP
0041CF  2  8D 19 00     	sta	SCRATCH0
0041D2  2               
0041D2  2               WGStrokeRect_horzEdge:
0041D2  2  BD 38 48     	lda TEXTLINES_L,x	; Compute video memory address of left edge of rect
0041D5  2  8D 28 00     	sta BASL
0041D8  2  BD 20 48     	lda TEXTLINES_H,x
0041DB  2  8D 29 00     	sta BASH
0041DE  2               
0041DE  2  AD 06 00     	lda	PARAM0
0041E1  2  4A           	lsr
0041E2  2  18           	clc
0041E3  2  6D 28 00     	adc	BASL
0041E6  2  8D 28 00     	sta BASL
0041E9  2  A9 00        	lda	#$0
0041EB  2  6D 29 00     	adc BASH
0041EE  2  8D 29 00     	sta BASH
0041F1  2               
0041F1  2  AD 06 00     	lda	PARAM0			; Left edge even?
0041F4  2  29 01        	and	#$01
0041F6  2  D0 45        	bne	WGStrokeRect_horzLoopOdd
0041F8  2               
0041F8  2               	; CASE 1: Left edge even-aligned, even width
0041F8  2  8D 54 C0     	SETSWITCH	PAGE2OFF
0041FB  2  AD 08 00     	lda	PARAM2
0041FE  2  4A           	lsr
0041FF  2  A8           	tay					; Start at right edge
004200  2  88           	dey
004201  2  5A           	phy					; We'll reuse this calculation for the odd columns
004202  2               
004202  2               WGStrokeRect_horzLoopEvenAligned0:	; Draw even columns
004202  2  AD 19 00     	lda	SCRATCH0					; Plot the character
004205  2  91 28        	sta	(BASL),y
004207  2  88           	dey
004208  2  10 F8        	bpl	WGStrokeRect_horzLoopEvenAligned0	; Loop for w/2
00420A  2               
00420A  2  8D 55 C0     	SETSWITCH	PAGE2ON			; Prepare for odd columns
00420D  2  7A           	ply								; Start at right edge again
00420E  2               
00420E  2               WGStrokeRect_horzLoopEvenAligned1:	; Draw odd columns
00420E  2  AD 19 00     	lda	SCRATCH0					; Plot the character
004211  2  91 28        	sta	(BASL),y
004213  2  88           	dey
004214  2  10 F8        	bpl	WGStrokeRect_horzLoopEvenAligned1	; Loop for w/2
004216  2               
004216  2  AD 08 00     	lda	PARAM2						; Is width even?
004219  2  29 01        	and	#$01
00421B  2  F0 0A        	beq	WGStrokeRect_horzLoopEvenAlignedEvenWidth
00421D  2               
00421D  2               	; CASE 1a: Left edge even aligned, odd width
00421D  2               	;SETSWITCH	PAGE2OFF
00421D  2  AD 08 00     	lda	PARAM2						; Fill in extra last column
004220  2  4A           	lsr
004221  2  A8           	tay
004222  2  AD 19 00     	lda	SCRATCH0					; Plot the character
004225  2  91 28        	sta	(BASL),y
004227  2               
004227  2               WGStrokeRect_horzLoopEvenAlignedEvenWidth:
004227  2  E8           	inx
004228  2  EC 07 00     	cpx	PARAM1
00422B  2  D0 56        	bne WGStrokeRect_vertEdge
00422D  2  18           	clc								; Prepare for bottom edge
00422E  2  AD 07 00     	lda PARAM1
004231  2  6D 09 00     	adc PARAM3
004234  2  AA           	tax
004235  2  A9 4C        	lda	#CH_BOTTOM
004237  2  8D 19 00     	sta SCRATCH0
00423A  2  4C D2 41     	jmp	WGStrokeRect_horzEdge
00423D  2               
00423D  2               WGStrokeRect_horzLoopOdd:
00423D  2               	; CASE 2: Left edge odd-aligned, even width
00423D  2  8D 55 C0     	SETSWITCH	PAGE2ON
004240  2  AD 08 00     	lda	PARAM2
004243  2  4A           	lsr
004244  2  A8           	tay					; Iterate w/2
004245  2  5A           	phy					; We'll reuse this calculation for the even columns
004246  2               
004246  2               WGStrokeRect_horzLoopOddAligned0:		; Draw even columns
004246  2  AD 19 00     	lda	SCRATCH0					; Plot the character
004249  2  91 28        	sta	(BASL),y
00424B  2  88           	dey
00424C  2  D0 F8        	bne	WGStrokeRect_horzLoopOddAligned0	; Loop for w/2
00424E  2               
00424E  2  8D 54 C0     	SETSWITCH	PAGE2OFF				; Prepare for odd columns
004251  2  7A           	ply									; Iterate w/2 again, shift left 1
004252  2  88           	dey
004253  2               
004253  2               WGStrokeRect_horzLoopOddAligned1:		; Draw even columns
004253  2  AD 19 00     	lda	SCRATCH0					; Plot the character
004256  2  91 28        	sta	(BASL),y
004258  2  88           	dey
004259  2  10 F8        	bpl	WGStrokeRect_horzLoopOddAligned1	; Loop for w/2
00425B  2               
00425B  2  AD 08 00     	lda	PARAM2						; Is width even?
00425E  2  29 01        	and	#$01
004260  2  F0 0B        	beq	WGStrokeRect_horzLoopOddAlignedEvenWidth
004262  2               
004262  2               	; CASE 2a: Left edge odd aligned, odd width
004262  2  AD 08 00     	lda	PARAM2						; Fill in extra last column
004265  2  3A           	dec
004266  2  4A           	lsr
004267  2  A8           	tay
004268  2  AD 19 00     	lda	SCRATCH0					; Plot the character
00426B  2  91 28        	sta	(BASL),y
00426D  2               
00426D  2               WGStrokeRect_horzLoopOddAlignedEvenWidth:
00426D  2  E8           	inx
00426E  2  EC 07 00     	cpx	PARAM1
004271  2  D0 10        	bne WGStrokeRect_vertEdge
004273  2  18           	clc								; Prepare for bottom edge
004274  2  AD 07 00     	lda PARAM1
004277  2  6D 09 00     	adc PARAM3
00427A  2  AA           	tax
00427B  2  A9 4C        	lda #CH_BOTTOM
00427D  2  8D 19 00     	sta SCRATCH0
004280  2  4C D2 41     	jmp	WGStrokeRect_horzEdge
004283  2               
004283  2               
004283  2               WGStrokeRect_vertEdge:
004283  2               	; Left and right edges
004283  2               	;
004283  2  18           	clc
004284  2  AD 07 00     	lda	PARAM1				; Compute bottom edge
004287  2  6D 09 00     	adc PARAM3
00428A  2  8D 19 00     	sta	SCRATCH0
00428D  2               
00428D  2  AE 07 00     	ldx	PARAM1				; Start with top edge
004290  2               
004290  2               WGStrokeRect_vertLoop:
004290  2               
004290  2  DA           	phx					; We'll need X back for now, but save the line number
004291  2               
004291  2  BD 38 48     	lda TEXTLINES_L,x	; Compute video memory address of left edge of rect
004294  2  8D 28 00     	sta BASL
004297  2  BD 20 48     	lda TEXTLINES_H,x
00429A  2  8D 29 00     	sta BASH
00429D  2               
00429D  2  AD 06 00     	lda	PARAM0
0042A0  2  3A           	dec
0042A1  2  4A           	lsr
0042A2  2  18           	clc
0042A3  2  6D 28 00     	adc	BASL
0042A6  2  8D 28 00     	sta BASL
0042A9  2  A9 00        	lda	#$0
0042AB  2  6D 29 00     	adc BASH
0042AE  2  8D 29 00     	sta BASH
0042B1  2               
0042B1  2  AD 06 00     	lda	PARAM0			; Left edge even?
0042B4  2  3A           	dec
0042B5  2  29 01        	and	#$01
0042B7  2  D0 3C        	bne	WGStrokeRect_vertLoopOdd
0042B9  2               
0042B9  2               	; CASE 1: Left edge even-aligned, even width
0042B9  2  8D 55 C0     	SETSWITCH	PAGE2ON
0042BC  2  A0 00        	ldy	#$0
0042BE  2  A9 5A        	lda	#CH_LEFT					; Plot the left edge
0042C0  2  91 28        	sta	(BASL),y
0042C2  2               
0042C2  2  AD 08 00     	lda	PARAM2						; Is width even?
0042C5  2  1A           	inc
0042C6  2  1A           	inc
0042C7  2  29 01        	and	#$01
0042C9  2  D0 12        	bne	WGStrokeRect_vertLoopEvenAlignedOddWidth
0042CB  2               
0042CB  2  AD 08 00     	lda PARAM2						; Calculate right edge
0042CE  2  1A           	inc
0042CF  2  1A           	inc
0042D0  2  4A           	lsr
0042D1  2  3A           	dec
0042D2  2  A8           	tay
0042D3  2  8D 54 C0     	SETSWITCH	PAGE2OFF
0042D6  2  A9 5F        	lda	#CH_RIGHT					; Plot the right edge
0042D8  2  91 28        	sta	(BASL),y
0042DA  2  4C EB 42     	jmp	WGStrokeRect_vertLoopEvenAlignedNextRow
0042DD  2               
0042DD  2               WGStrokeRect_vertLoopEvenAlignedOddWidth:
0042DD  2               	; CASE 1a: Left edge even-aligned, odd width
0042DD  2  8D 55 C0     	SETSWITCH	PAGE2ON
0042E0  2  AD 08 00     	lda PARAM2						; Calculate right edge
0042E3  2  1A           	inc
0042E4  2  1A           	inc
0042E5  2  4A           	lsr
0042E6  2  A8           	tay
0042E7  2  A9 5F        	lda	#CH_RIGHT					; Plot the right edge
0042E9  2  91 28        	sta	(BASL),y
0042EB  2               
0042EB  2               WGStrokeRect_vertLoopEvenAlignedNextRow:
0042EB  2  FA           	plx								; Prepare for next row
0042EC  2  E8           	inx
0042ED  2  EC 19 00     	cpx	SCRATCH0
0042F0  2  D0 9E        	bne	WGStrokeRect_vertLoop
0042F2  2  4C 33 43     	jmp	WGStrokeRect_done
0042F5  2               
0042F5  2               
0042F5  2               WGStrokeRect_vertLoopOdd:
0042F5  2               	; CASE 2: Left edge odd-aligned, even width
0042F5  2  8D 54 C0     	SETSWITCH	PAGE2OFF
0042F8  2  A0 00        	ldy	#$0
0042FA  2  A9 5A        	lda	#CH_LEFT					; Plot the left edge
0042FC  2  91 28        	sta	(BASL),y
0042FE  2               
0042FE  2  AD 08 00     	lda	PARAM2						; Is width even?
004301  2  1A           	inc
004302  2  1A           	inc
004303  2  29 01        	and	#$01
004305  2  D0 11        	bne	WGStrokeRect_vertLoopOddAlignedOddWidth
004307  2               
004307  2  AD 08 00     	lda PARAM2						; Calculate right edge
00430A  2  1A           	inc
00430B  2  1A           	inc
00430C  2  4A           	lsr
00430D  2  A8           	tay
00430E  2  8D 55 C0     	SETSWITCH	PAGE2ON
004311  2  A9 5F        	lda	#CH_RIGHT					; Plot the right edge
004313  2  91 28        	sta	(BASL),y
004315  2  4C 26 43     	jmp	WGStrokeRect_vertLoopOddAlignedNextRow
004318  2               
004318  2               WGStrokeRect_vertLoopOddAlignedOddWidth:
004318  2               	; CASE 2a: Left edge odd-aligned, odd width
004318  2  8D 54 C0     	SETSWITCH	PAGE2OFF
00431B  2  AD 08 00     	lda PARAM2						; Calculate right edge
00431E  2  1A           	inc
00431F  2  1A           	inc
004320  2  4A           	lsr
004321  2  A8           	tay
004322  2  A9 5F        	lda	#CH_RIGHT					; Plot the right edge
004324  2  91 28        	sta	(BASL),y
004326  2               
004326  2               WGStrokeRect_vertLoopOddAlignedNextRow:
004326  2  FA           	plx								; Prepare for next row
004327  2  E8           	inx
004328  2  EC 19 00     	cpx	SCRATCH0
00432B  2  D0 03        	bne	WGStrokeRect_vertLoopJmp
00432D  2  4C 33 43     	jmp WGStrokeRect_done
004330  2               WGStrokeRect_vertLoopJmp:
004330  2  4C 90 42     	jmp WGStrokeRect_vertLoop
004333  2               
004333  2               WGStrokeRect_done:
004333  2  68 8D 1A 00  	RESTORE_ZPS
004337  2  68 8D 19 00  
00433B  2  68 A8 68 AA  	RESTORE_AXY
00433F  2  68           
004340  2  60           	rts
004341  2               
004341  2               
004341  2               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
004341  2               ; WGPlot
004341  2               ; Plots a character at current cursor position (assumes 80 cols)
004341  2               ; A: Character to plot
004341  2               ; Side effects: Clobbers S0, BASL,BASH
004341  2               ;
004341  2               WGPlot:
004341  2  8D 19 00     	sta SCRATCH0
004344  2  48 8A 48 98  	SAVE_AXY
004348  2  48           
004349  2               
004349  2  AE 16 47     	ldx	WG_CURSORY
00434C  2  BD 38 48     	lda TEXTLINES_L,x	; Compute video memory address of point
00434F  2  8D 28 00     	sta BASL
004352  2  BD 20 48     	lda TEXTLINES_H,x
004355  2  8D 29 00     	sta BASH
004358  2               
004358  2  AD 15 47     	lda	WG_CURSORX
00435B  2  4A           	lsr
00435C  2  18           	clc
00435D  2  6D 28 00     	adc	BASL
004360  2  8D 28 00     	sta BASL
004363  2  A9 00        	lda	#$0
004365  2  6D 29 00     	adc BASH
004368  2  8D 29 00     	sta BASH
00436B  2               
00436B  2  AD 15 47     	lda	WG_CURSORX			; X even?
00436E  2  29 01        	and	#$01
004370  2  D0 0D        	bne	WGPlot_xOdd
004372  2               
004372  2  8D 55 C0     	SETSWITCH	PAGE2ON		; Plot the character
004375  2  A0 00        	ldy	#$0
004377  2  AD 19 00     	lda	SCRATCH0
00437A  2  91 28        	sta	(BASL),y
00437C  2  4C 89 43     	jmp WGPlot_done
00437F  2               
00437F  2               WGPlot_xOdd:
00437F  2  8D 54 C0     	SETSWITCH	PAGE2OFF	; Plot the character
004382  2  A0 00        	ldy	#$0
004384  2  AD 19 00     	lda	SCRATCH0
004387  2  91 28        	sta	(BASL),y
004389  2               
004389  2               WGPlot_done:
004389  2  68 A8 68 AA  	RESTORE_AXY
00438D  2  68           
00438E  2  60           	rts
00438F  2               
00438F  2               
00438F  2               
00438F  2               
00438F  2               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00438F  2               ; WGPrintASCII
00438F  2               ; Prints a null-terminated ASCII string at the current view's
00438F  2               ; cursor position. Clips to current view
00438F  2               ; PARAM0: String pointer, LSB
00438F  2               ; PARAM1: String pointer, MSB
00438F  2               ; Side effects: Clobbers BASL,BASH
00438F  2               ;
00438F  2               WGPrintASCII:
00438F  2  48 8A 48 98  	SAVE_AXY
004393  2  48           
004394  2  AD 19 00 48  	SAVE_ZPS
004398  2  AD 1A 00 48  
00439C  2               
00439C  2  20 DE 45     	jsr	WGSyncGlobalCursor
00439F  2               
00439F  2  AD 19 47 29  	LDY_ACTIVEVIEW
0043A3  2  0F 0A 0A 0A  
0043A7  2  0A 0A 0A 0A  
0043AD  2               
0043AD  2  C8           	iny						; Clip to upper extent
0043AE  2  AD 16 47     	lda	WG_CURSORY
0043B1  2  D9 1F 47     	cmp WG_VIEWRECORDS,y
0043B4  2  90 58        	bcc	WGPrintASCII_done
0043B6  2               
0043B6  2  B9 1F 47     	lda	WG_VIEWRECORDS,y	; Clip to lower extent
0043B9  2  C8           	iny
0043BA  2  C8           	iny
0043BB  2  18           	clc
0043BC  2  79 1F 47     	adc	WG_VIEWRECORDS,y
0043BF  2  3A           	dec
0043C0  2  CD 16 47     	cmp	WG_CURSORY
0043C3  2  90 49        	bcc	WGPrintASCII_done
0043C5  2               
0043C5  2  20 BD 40     	jsr	WGStrLen			; We'll need the length of the string to clip horizontally
0043C8  2  8D 19 00     	sta	SCRATCH0
0043CB  2               
0043CB  2  88           	dey						; Clip left/right extents
0043CC  2  88           	dey
0043CD  2  88           	dey
0043CE  2  AD 15 47     	lda	WG_CURSORX			; startIndex = -(globalX - windowStartX)
0043D1  2  38           	sec
0043D2  2  F9 1F 47     	sbc	WG_VIEWRECORDS,y
0043D5  2  49 FF        	eor	#$ff
0043D7  2  1A           	inc
0043D8  2  30 0F        	bmi	WGPrintASCII_leftEdgeStart
0043DA  2  CD 19 00     	cmp	SCRATCH0
0043DD  2  B0 2F        	bcs	WGPrintASCII_done	; Entire string is left of window
0043DF  2               
0043DF  2  AA           	tax						; Starting mid-string on the left
0043E0  2  B9 1F 47     	lda	WG_VIEWRECORDS,y
0043E3  2  8D 15 47     	sta	WG_CURSORX
0043E6  2  8A           	txa
0043E7  2  80 02        	bra	WGPrintASCII_findRightEdge
0043E9  2               
0043E9  2               WGPrintASCII_leftEdgeStart:
0043E9  2  A9 00        	lda #0
0043EB  2               
0043EB  2               WGPrintASCII_findRightEdge:
0043EB  2  48           	pha						; Stash start index
0043EC  2               
0043EC  2  B9 1F 47     	lda	WG_VIEWRECORDS,y
0043EF  2  C8           	iny
0043F0  2  C8           	iny
0043F1  2  18           	clc
0043F2  2  79 1F 47     	adc	WG_VIEWRECORDS,y
0043F5  2  AA           	tax
0043F6  2  CA           	dex
0043F7  2  7A           	ply						; End cursor in X, start index in Y
0043F8  2               
0043F8  2               WGPrintASCII_loop:
0043F8  2  EC 15 47     	cpx	WG_CURSORX
0043FB  2  90 11        	bcc	WGPrintASCII_done	; Hit the right edge of the window
0043FD  2  B1 06        	lda	(PARAM0),y
0043FF  2  F0 0D        	beq	WGPrintASCII_done	; Hit the end of the string
004401  2  09 80        	ora #$80
004403  2  20 41 43     	jsr	WGPlot
004406  2               
004406  2  C8           	iny
004407  2  18           	clc
004408  2  EE 15 47     	inc WG_CURSORX
00440B  2  4C F8 43     	jmp	WGPrintASCII_loop
00440E  2               
00440E  2               WGPrintASCII_done:
00440E  2  68 8D 1A 00  	RESTORE_ZPS
004412  2  68 8D 19 00  
004416  2  68 A8 68 AA  	RESTORE_AXY
00441A  2  68           
00441B  2  60           	rts
00441C  2               
00441C  2               
00441C  2               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00441C  2               ; WGPrint
00441C  2               ; Prints a null-terminated Apple string at the current view's
00441C  2               ; cursor position. Clips to current view.
00441C  2               ; PARAM0: String pointer, LSB
00441C  2               ; PARAM1: String pointer, MSB
00441C  2               ; Side effects: Clobbers SA,BASL,BASH
00441C  2               ;
00441C  2               WGPrint:
00441C  2  48 8A 48 98  	SAVE_AXY
004420  2  48           
004421  2  AD 19 00 48  	SAVE_ZPS
004425  2  AD 1A 00 48  
004429  2               
004429  2  20 BD 40     	jsr	WGStrLen			; We'll need the length of the string
00442C  2  8D 1A 00     	sta	SCRATCH1
00442F  2               
00442F  2  AD 19 47 29  	LDX_ACTIVEVIEW			; Cache view width for later
004433  2  0F 0A 0A 0A  
004437  2  0A 0A 0A 0A  
00443D  2  E8           	inx
00443E  2  E8           	inx
00443F  2  E8           	inx
004440  2  E8           	inx
004441  2  E8           	inx
004442  2  E8           	inx
004443  2  E8           	inx
004444  2  BD 1F 47     	lda WG_VIEWRECORDS,x
004447  2  8D 1F 48     	sta WG_SCRATCHA
00444A  2  E8           	inx						; Leave X pointing at view height, for later quick access
00444B  2               
00444B  2  A0 00        	ldy #0
00444D  2               
00444D  2               WGPrint_lineLoopFirst:		; Calculating start of first line is slightly different
00444D  2  AD 18 47     	lda	WG_LOCALCURSORY
004450  2  CD 1B 47     	cmp	WG_VIEWCLIP+1
004453  2  90 18        	bcc	WGPrint_skipToEndFirst	; This line is above the clip box
004455  2               
004455  2  AD 17 47     	lda	WG_LOCALCURSORX		; Find start of line within clip box
004458  2  CD 1A 47     	cmp WG_VIEWCLIP+0
00445B  2  B0 54        	bcs WGPrint_visibleChars
00445D  2               
00445D  2  AD 1A 47     	lda	WG_VIEWCLIP+0
004460  2  38           	sec						; Line begins before left clip plane
004461  2  ED 17 47     	sbc WG_LOCALCURSORX
004464  2  A8           	tay						; Advance string index and advance cursor into clip box
004465  2  AD 1A 47     	lda WG_VIEWCLIP+0
004468  2  8D 17 47     	sta	WG_LOCALCURSORX
00446B  2  80 44        	bra WGPrint_visibleChars
00446D  2               
00446D  2               WGPrint_skipToEndFirst:
00446D  2  AD 1F 48     	lda WG_SCRATCHA			; Skip string index ahead by distance to EOL
004470  2  38           	sec
004471  2  ED 17 47     	sbc WG_LOCALCURSORX
004474  2  CD 1A 00     	cmp	SCRATCH1
004477  2  B0 7E        	bcs	WGPrint_done
004479  2  A8           	tay
00447A  2               
00447A  2  AD 1F 48     	lda	WG_SCRATCHA			; Skip cursor ahead to EOL
00447D  2  8D 17 47     	sta WG_LOCALCURSORX
004480  2  80 5C        	bra WGPrint_nextLine
004482  2               
004482  2               WGPrint_skipToEnd:
004482  2  98           	tya						; Skip string index ahead by distance to EOL
004483  2  18           	clc
004484  2  6D 1F 48     	adc WG_SCRATCHA
004487  2  CD 1A 00     	cmp	SCRATCH1
00448A  2  B0 6A        	bcs	WGPrint_done2
00448C  2  A8           	tay
00448D  2               
00448D  2  AD 1F 48     	lda	WG_SCRATCHA			; Skip cursor ahead to EOL
004490  2  8D 17 47     	sta WG_LOCALCURSORX
004493  2  80 49        	bra WGPrint_nextLine
004495  2               
004495  2               WGPrint_lineLoop:
004495  2  AD 18 47     	lda	WG_LOCALCURSORY
004498  2  CD 1B 47     	cmp	WG_VIEWCLIP+1
00449B  2  90 E5        	bcc	WGPrint_skipToEnd	; This line is above the clip box
00449D  2               
00449D  2  AD 17 47     	lda	WG_LOCALCURSORX		; Find start of line within clip box
0044A0  2  CD 1A 47     	cmp WG_VIEWCLIP+0
0044A3  2  B0 0C        	bcs WGPrint_visibleChars
0044A5  2               
0044A5  2  98           	tya
0044A6  2  18           	clc
0044A7  2  6D 1A 47     	adc	WG_VIEWCLIP+0		; Jump ahead by left span
0044AA  2  A8           	tay
0044AB  2               
0044AB  2  AD 1A 47     	lda WG_VIEWCLIP+0		; Set cursor to left edge of visible area
0044AE  2  8D 17 47     	sta	WG_LOCALCURSORX
0044B1  2               
0044B1  2               WGPrint_visibleChars:
0044B1  2  20 DE 45     	jsr	WGSyncGlobalCursor
0044B4  2               
0044B4  2               WGPrint_charLoop:
0044B4  2  B1 06        	lda	(PARAM0),y			; Draw current character
0044B6  2  F0 3F        	beq WGPrint_done
0044B8  2  09 80        	ora #$80
0044BA  2  20 41 43     	jsr	WGPlot
0044BD  2  C8           	iny
0044BE  2               
0044BE  2  EE 15 47     	inc WG_CURSORX			; Advance cursors
0044C1  2  EE 17 47     	inc WG_LOCALCURSORX
0044C4  2               
0044C4  2  AD 17 47     	lda WG_LOCALCURSORX
0044C7  2  CD 1F 48     	cmp	WG_SCRATCHA			; Check for wrap boundary
0044CA  2  F0 12        	beq	WGPrint_nextLine
0044CC  2  CD 1C 47     	cmp	WG_VIEWCLIP+2		; Check for right clip plane
0044CF  2  F0 02        	beq	WGPrint_endVisible
0044D1  2  80 E1        	bra WGPrint_charLoop
0044D3  2               
0044D3  2               WGPrint_endVisible:
0044D3  2  98           	tya
0044D4  2  18           	clc
0044D5  2  6D 1E 47     	adc	WG_VIEWCLIP+4		; Advance string index by right span
0044D8  2  CD 1A 00     	cmp	SCRATCH1
0044DB  2  B0 1A        	bcs	WGPrint_done
0044DD  2  A8           	tay
0044DE  2               
0044DE  2               WGPrint_nextLine:
0044DE  2  EE 18 47     	inc	WG_LOCALCURSORY			; Advance cursor
0044E1  2  AD 18 47     	lda	WG_LOCALCURSORY
0044E4  2  CD 1D 47     	cmp	WG_VIEWCLIP+3			; Check for bottom clip plane
0044E7  2  F0 0E        	beq	WGPrint_done
0044E9  2  DD 1F 47     	cmp	WG_VIEWRECORDS,x		; Check for bottom of view
0044EC  2  F0 09        	beq	WGPrint_done
0044EE  2               
0044EE  2  A9 00        	lda #0						; Wrap to next line
0044F0  2  8D 17 47     	sta	WG_LOCALCURSORX
0044F3  2  4C 95 44     	jmp WGPrint_lineLoop
0044F6  2               
0044F6  2               WGPrint_done2:
0044F6  2  00           	brk
0044F7  2               WGPrint_done:
0044F7  2  68 8D 1A 00  	RESTORE_ZPS
0044FB  2  68 8D 19 00  
0044FF  2  68 A8 68 AA  	RESTORE_AXY
004503  2  68           
004504  2  60           	rts
004505  2               
004505  1               .include "views.s"
004505  2               ;
004505  2               ;  views.s
004505  2               ;  Management routines for GUI views
004505  2               ;
004505  2               ;  Created by Quinn Dunki on 8/15/14.
004505  2               ;  Copyright (c) 2014 One Girl, One Laptop Productions. All rights reserved.
004505  2               ;
004505  2               
004505  2               
004505  2               
004505  2               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
004505  2               ; WGCreateView
004505  2               ; Creates a new view
004505  2               ; PARAM0: Pointer to ASCII configuration string (LSB)
004505  2               ; PARAM1: Pointer to ASCII configuration string (MSB)
004505  2               ;
004505  2               ; Configuration string: "STXXYYSWSHVWVH"
004505  2               ; ST: (4:4) Style:ID
004505  2               ; XX: Screen X origin
004505  2               ; YY: Screen Y origin
004505  2               ; SW: Screen width
004505  2               ; SH: Screen height
004505  2               ; VW: View Width
004505  2               ; VH: View Height
004505  2               ;
004505  2               WGCreateView:
004505  2  48 8A 48 98  	SAVE_AXY
004509  2  48           
00450A  2  AD 19 00 48  	SAVE_ZPS
00450E  2  AD 1A 00 48  
004512  2               
004512  2  A0 00        	ldy #0
004514  2  20 A6 40     	jsr	scanHex8
004517  2  48           	pha
004518  2               
004518  2  29 0F        	and #%00001111	; Find our new view record
00451A  2  0A           	asl
00451B  2  0A           	asl
00451C  2  0A           	asl
00451D  2  0A           	asl				; Records are 8 bytes wide
00451E  2  AA           	tax
00451F  2               
00451F  2  68           	pla				; Cache style nybble for later
004520  2  4A           	lsr
004521  2  4A           	lsr
004522  2  4A           	lsr
004523  2  4A           	lsr
004524  2  48           	pha
004525  2               
004525  2  20 A6 40     	jsr	scanHex8
004528  2  9D 1F 47     	sta	WG_VIEWRECORDS,x	; Screen X
00452B  2  E8           	inx
00452C  2               
00452C  2  20 A6 40     	jsr	scanHex8
00452F  2  9D 1F 47     	sta	WG_VIEWRECORDS,x	; Screen Y
004532  2  E8           	inx
004533  2               
004533  2  20 A6 40     	jsr	scanHex8
004536  2  9D 1F 47     	sta	WG_VIEWRECORDS,x	; Screen Width
004539  2  E8           	inx
00453A  2               
00453A  2  20 A6 40     	jsr	scanHex8
00453D  2  9D 1F 47     	sta	WG_VIEWRECORDS,x	; Screen Height
004540  2  E8           	inx
004541  2               
004541  2  68           	pla
004542  2  9D 1F 47     	sta	WG_VIEWRECORDS,x	; Style
004545  2  E8           	inx
004546  2               
004546  2  A9 00        	lda	#0					; Initialize scrolling
004548  2  9D 1F 47     	sta	WG_VIEWRECORDS,x
00454B  2  E8           	inx
00454C  2  9D 1F 47     	sta	WG_VIEWRECORDS,x
00454F  2  E8           	inx
004550  2               
004550  2  20 A6 40     	jsr	scanHex8
004553  2  9D 1F 47     	sta	WG_VIEWRECORDS,x	; View Width
004556  2  E8           	inx
004557  2               
004557  2  20 A6 40     	jsr	scanHex8
00455A  2  9D 1F 47     	sta	WG_VIEWRECORDS,x	; View Height
00455D  2               
00455D  2               WGCreateView_done:
00455D  2  68 8D 1A 00  	RESTORE_ZPS
004561  2  68 8D 19 00  
004565  2  68 A8 68 AA  	RESTORE_AXY
004569  2  68           
00456A  2  60           	rts
00456B  2               
00456B  2               
00456B  2               
00456B  2               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00456B  2               ; WGPaintView
00456B  2               ; Paints the current view
00456B  2               ;
00456B  2               WGPaintView:
00456B  2  48 98 48     	SAVE_AY
00456E  2  AD 06 00 48  	SAVE_ZPP
004572  2  AD 07 00 48  
004576  2  AD 08 00 48  
00457E  2               
00457E  2  AD 19 47 29  	LDY_ACTIVEVIEW
004582  2  0F 0A 0A 0A  
004586  2  0A 0A 0A 0A  
00458C  2               
00458C  2  B9 1F 47     	lda	WG_VIEWRECORDS,y	; Fetch the record
00458F  2  8D 06 00     	sta PARAM0
004592  2  C8           	iny
004593  2  B9 1F 47     	lda	WG_VIEWRECORDS,y
004596  2  8D 07 00     	sta PARAM1
004599  2  C8           	iny
00459A  2  B9 1F 47     	lda	WG_VIEWRECORDS,y
00459D  2  8D 08 00     	sta PARAM2
0045A0  2  C8           	iny
0045A1  2  B9 1F 47     	lda	WG_VIEWRECORDS,y
0045A4  2  8D 09 00     	sta PARAM3
0045A7  2               
0045A7  2  20 BC 41     	jsr WGStrokeRect
0045AA  2               
0045AA  2               WGPaintView_done:
0045AA  2  68 8D 09 00  	RESTORE_ZPP
0045AE  2  68 8D 08 00  
0045B2  2  68 8D 07 00  
0045BA  2  68 A8 68     	RESTORE_AY
0045BD  2  60           	rts
0045BE  2               
0045BE  2               
0045BE  2               
0045BE  2               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0045BE  2               ; WGSelectView
0045BE  2               ; Selects the active view
0045BE  2               ; A: ID
0045BE  2               ;
0045BE  2               WGSelectView:
0045BE  2  48 8A 48 98  	SAVE_AXY
0045C2  2  48           
0045C3  2  8D 19 47     	sta	WG_ACTIVEVIEW
0045C6  2               
0045C6  2               	; Initialize cursor to local origin
0045C6  2  A9 00        	lda #0
0045C8  2  8D 17 47     	sta WG_LOCALCURSORX
0045CB  2  8D 18 47     	sta WG_LOCALCURSORY
0045CE  2               
0045CE  2  20 6D 46     	jsr	cacheClipPlanes		; View changed, so clipping cache is stale
0045D1  2               
0045D1  2               WGSelectView_done:
0045D1  2  68 A8 68 AA  	RESTORE_AXY
0045D5  2  68           
0045D6  2  60           	rts
0045D7  2               
0045D7  2               
0045D7  2               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0045D7  2               ; WGSetCursor
0045D7  2               ; Sets the current local view cursor
0045D7  2               ; X: X
0045D7  2               ; Y: Y
0045D7  2               ;
0045D7  2               WGSetCursor:
0045D7  2  8E 17 47     	stx	WG_LOCALCURSORX
0045DA  2  8C 18 47     	sty	WG_LOCALCURSORY
0045DD  2  60           	rts
0045DE  2               
0045DE  2               
0045DE  2               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0045DE  2               ; WGSyncGlobalCursor
0045DE  2               ; Synchronizes the global cursor with the current local view's
0045DE  2               ; cursor
0045DE  2               ;
0045DE  2               WGSyncGlobalCursor:
0045DE  2  48 98 48     	SAVE_AY
0045E1  2               
0045E1  2               	; X
0045E1  2  AD 19 47 29  	LDY_ACTIVEVIEW
0045E5  2  0F 0A 0A 0A  
0045E9  2  0A 0A 0A 0A  
0045EF  2               
0045EF  2  18           	clc						; Transform to viewspace
0045F0  2  AD 17 47     	lda WG_LOCALCURSORX
0045F3  2  79 1F 47     	adc	WG_VIEWRECORDS,y
0045F6  2               
0045F6  2  C8           	iny
0045F7  2  C8           	iny
0045F8  2  C8           	iny
0045F9  2  C8           	iny
0045FA  2  C8           	iny
0045FB  2  18           	clc
0045FC  2  79 1F 47     	adc	WG_VIEWRECORDS,y	; Transform to scrollspace
0045FF  2  8D 15 47     	sta WG_CURSORX
004602  2               
004602  2               	; Y
004602  2  AD 19 47 29  	LDY_ACTIVEVIEW
004606  2  0F 0A 0A 0A  
00460A  2  0A 0A 0A 0A  
004610  2  C8           	iny
004611  2               
004611  2  18           	clc						; Transform to viewspace
004612  2  AD 18 47     	lda WG_LOCALCURSORY
004615  2  79 1F 47     	adc	WG_VIEWRECORDS,y
004618  2               
004618  2  C8           	iny
004619  2  C8           	iny
00461A  2  C8           	iny
00461B  2  C8           	iny
00461C  2  C8           	iny
00461D  2  18           	clc
00461E  2  79 1F 47     	adc	WG_VIEWRECORDS,y	; Transform to scrollspace
004621  2  8D 16 47     	sta WG_CURSORY
004624  2               
004624  2               WGSyncGlobalCursor_done:
004624  2  68 A8 68     	RESTORE_AY
004627  2  60           	rts
004628  2               
004628  2               
004628  2               
004628  2               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
004628  2               ; WGScrollX
004628  2               ; Scrolls the current view horizontally
004628  2               ; A: Delta to scroll
004628  2               ; Side effects: Clobbers A
004628  2               ;
004628  2               WGScrollX:
004628  2  5A           	phy
004629  2  48           	pha
00462A  2  AD 19 47 29  	LDY_ACTIVEVIEW
00462E  2  0F 0A 0A 0A  
004632  2  0A 0A 0A 0A  
004638  2  68           	pla
004639  2  C8           	iny
00463A  2  C8           	iny
00463B  2  C8           	iny
00463C  2  C8           	iny
00463D  2  C8           	iny
00463E  2  18           	clc
00463F  2  79 1F 47     	adc	WG_VIEWRECORDS,y
004642  2  99 1F 47     	sta	WG_VIEWRECORDS,y
004645  2               
004645  2  20 6D 46     	jsr	cacheClipPlanes		; Scroll offset changed, so clipping cache is stale
004648  2               
004648  2               WGScrollX_done:
004648  2  7A           	ply
004649  2  60           	rts
00464A  2               
00464A  2               
00464A  2               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00464A  2               ; WGScrollY
00464A  2               ; Scrolls the current view vertically
00464A  2               ; A: Delta to scroll
00464A  2               ; Side effects: Clobbers A
00464A  2               ;
00464A  2               WGScrollY:
00464A  2  5A           	phy
00464B  2  48           	pha
00464C  2  AD 19 47 29  	LDY_ACTIVEVIEW
004650  2  0F 0A 0A 0A  
004654  2  0A 0A 0A 0A  
00465A  2  68           	pla
00465B  2  C8           	iny
00465C  2  C8           	iny
00465D  2  C8           	iny
00465E  2  C8           	iny
00465F  2  C8           	iny
004660  2  C8           	iny
004661  2  18           	clc
004662  2  79 1F 47     	adc	WG_VIEWRECORDS,y
004665  2  99 1F 47     	sta	WG_VIEWRECORDS,y
004668  2               
004668  2  20 6D 46     	jsr	cacheClipPlanes		; Scroll offset changed, so clipping cache is stale
00466B  2               
00466B  2               WGScrollY_done:
00466B  2  7A           	ply
00466C  2  60           	rts
00466D  2               
00466D  2               
00466D  2               
00466D  2               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00466D  2               ; cacheClipPlanes
00466D  2               ; Internal routine to cache the clipping planes for the view
00466D  2               ;
00466D  2               cacheClipPlanes:
00466D  2  48 98 48     	SAVE_AY
004670  2               
004670  2               	; Compute clip planes in view space
004670  2  AD 19 47 29  	LDY_ACTIVEVIEW
004674  2  0F 0A 0A 0A  
004678  2  0A 0A 0A 0A  
00467E  2               
00467E  2  C8           	iny						; Left edge
00467F  2  C8           	iny
004680  2  C8           	iny
004681  2  C8           	iny
004682  2  C8           	iny
004683  2  B9 1F 47     	lda	WG_VIEWRECORDS,y
004686  2  49 FF        	eor #$ff
004688  2  1A           	inc
004689  2  8D 1A 47     	sta	WG_VIEWCLIP+0
00468C  2               
00468C  2  88           	dey						; Right edge
00468D  2  88           	dey
00468E  2  88           	dey
00468F  2  18           	clc
004690  2  79 1F 47     	adc	WG_VIEWRECORDS,y
004693  2  8D 1C 47     	sta	WG_VIEWCLIP+2
004696  2               
004696  2  C8           	iny						; Right span (distance from window edge to view edge, in viewspace
004697  2  C8           	iny
004698  2  C8           	iny
004699  2  C8           	iny
00469A  2  C8           	iny
00469B  2  B9 1F 47     	lda	WG_VIEWRECORDS,y
00469E  2  38           	sec
00469F  2  ED 1C 47     	sbc	WG_VIEWCLIP+2
0046A2  2  8D 1E 47     	sta	WG_VIEWCLIP+4
0046A5  2               
0046A5  2  88           	dey						; Top edge
0046A6  2  B9 1F 47     	lda	WG_VIEWRECORDS,y
0046A9  2  49 FF        	eor #$ff
0046AB  2  1A           	inc
0046AC  2  8D 1B 47     	sta	WG_VIEWCLIP+1
0046AF  2               
0046AF  2  88           	dey						; Bottom edge
0046B0  2  88           	dey
0046B1  2  88           	dey
0046B2  2  18           	clc
0046B3  2  79 1F 47     	adc	WG_VIEWRECORDS,y
0046B6  2  8D 1D 47     	sta	WG_VIEWCLIP+3
0046B9  2               
0046B9  2  68 A8 68     	RESTORE_AY
0046BC  2  60           	rts
0046BD  2               
0046BD  2               
0046BD  2               
0046BD  1               .include "unit_test.s"
0046BD  2               ;
0046BD  2               ;  unit_test.s
0046BD  2               ;  WeeGui
0046BD  2               ;
0046BD  2               ;  Unit tests of various systems
0046BD  2               ;
0046BD  2               ;  Created by Quinn Dunki on 8/15/14.
0046BD  2               ;  Copyright (c) 2014 One Girl, One Laptop Productions. All rights reserved.
0046BD  2               ;
0046BD  2               
0046BD  2               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0046BD  2               ; tortureTestRects
0046BD  2               ; Strokes and paints rectangles of many different geometries
0046BD  2               ;
0046BD  2               	; Stack:
0046BD  2               	; Curr X
0046BD  2               	; Curr Y
0046BD  2               	; Curr Width
0046BD  2               	; Curr Height
0046BD  2               tortureTestRects:
0046BD  2  20 CA 40     	jsr WGClearScreen
0046C0  2               
0046C0  2  A9 26        	lda	#38			; Initialize
0046C2  2  48           	pha
0046C3  2  A9 0B        	lda #11
0046C5  2  48           	pha
0046C6  2  A9 02        	lda #2
0046C8  2  48           	pha
0046C9  2  A9 02        	lda #2
0046CB  2  48           	pha
0046CC  2               
0046CC  2               tortureTestRectsLoop:
0046CC  2               
0046CC  2  20 CA 40     	jsr WGClearScreen
0046CF  2               
0046CF  2  BA           	tsx
0046D0  2  E8           	inx
0046D1  2  BD 00 01     	lda	$0100,x		; Load Height, then modify
0046D4  2  8D 09 00     	sta	PARAM3
0046D7  2  1A           	inc
0046D8  2  1A           	inc
0046D9  2  9D 00 01     	sta	$0100,x
0046DC  2  C9 19        	cmp	#25
0046DE  2  B0 2E        	bcs	tortureTestRectsDone
0046E0  2               
0046E0  2  E8           	inx				; Load Width, then modify
0046E1  2  BD 00 01     	lda	$0100,x
0046E4  2  8D 08 00     	sta PARAM2
0046E7  2  1A           	inc
0046E8  2  1A           	inc
0046E9  2  1A           	inc
0046EA  2  1A           	inc
0046EB  2  1A           	inc
0046EC  2  1A           	inc
0046ED  2  9D 00 01     	sta	$0100,x
0046F0  2               
0046F0  2  E8           	inx				; Load Y, then modify
0046F1  2  BD 00 01     	lda	$0100,x
0046F4  2  8D 07 00     	sta	PARAM1
0046F7  2  3A           	dec
0046F8  2  9D 00 01     	sta	$0100,x
0046FB  2               
0046FB  2  E8           	inx				; Load X, then modify
0046FC  2  BD 00 01     	lda	$0100,x
0046FF  2  8D 06 00     	sta	PARAM0
004702  2  3A           	dec
004703  2  3A           	dec
004704  2  3A           	dec
004705  2  9D 00 01     	sta	$0100,x
004708  2               
004708  2               ;	ldx	#'Q'+$80
004708  2               ;	jsr	WGFillRect
004708  2  20 BC 41     	jsr	WGStrokeRect
00470B  2               
00470B  2               ;	jsr delayShort
00470B  2               
00470B  2  4C CC 46     	jmp tortureTestRectsLoop
00470E  2               
00470E  2               tortureTestRectsDone:
00470E  2  68           	pla
00470F  2  68           	pla
004710  2  68           	pla
004711  2  68           	pla
004712  2  4C BD 46     	jmp	tortureTestRects
004715  2               
004715  2               
004715  1               .include "memory.s"
004715  2               ;
004715  2               ;  memory.s
004715  2               ;  Memory mapping information
004715  2               ;
004715  2               ;  Created by Quinn Dunki on 8/15/14.
004715  2               ;  Copyright (c) 2014 One Girl, One Laptop Productions. All rights reserved.
004715  2               ;
004715  2               
004715  2               
004715  2               ; Reserved locations
004715  2               
004715  2               INVERSE			= $32
004715  2               BASL			= $28
004715  2               BASH			= $29
004715  2               
004715  2               
004715  2               ; Zero page locations we use (unused by Monitor, Applesoft, or ProDOS)
004715  2               PARAM0			= $06
004715  2               PARAM1			= $07
004715  2               PARAM2			= $08
004715  2               PARAM3			= $09
004715  2               SCRATCH0		= $19
004715  2               SCRATCH1		= $1A
004715  2               
004715  2               ; Constants
004715  2               
004715  2               CHAR_NORMAL = $ff
004715  2               CHAR_INVERSE = $3f
004715  2               CHAR_FLASH = $7f
004715  2               
004715  2               
004715  2               ; ROM entry points
004715  2               
004715  2               COUT			= $fded
004715  2               BASCALC			= $fbc1
004715  2               PRBYTE			= $fdda
004715  2               
004715  2               
004715  2               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
004715  2               ; System state
004715  2               ;
004715  2               WG_CURSORX:				; In screenspace
004715  2  00           .byte	0
004716  2               WG_CURSORY:
004716  2  00           .byte	0
004717  2               
004717  2               WG_LOCALCURSORX:		; In current viewspace
004717  2  00           .byte	0
004718  2               WG_LOCALCURSORY:
004718  2  00           .byte	0
004719  2               
004719  2               WG_ACTIVEVIEW:
004719  2  00           .byte 0
00471A  2               
00471A  2               WG_VIEWCLIP:
00471A  2               	; X0,Y0,X1,Y1. Edges of current window, in view space, right span
00471A  2  00 00 00 00  .byte 0,0,0,0,0
00471E  2  00           
00471F  2               
00471F  2               WG_VIEWRECORDS:
00471F  2               	; X, Y, Screen Width, Screen Height, Style, X Offset, Y Offset, View Width, View Height
00471F  2  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
004723  2  00 00 00 00  
004727  2  00 00 00 00  
00472F  2  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
004733  2  00 00 00 00  
004737  2  00 00 00 00  
00473F  2  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
004743  2  00 00 00 00  
004747  2  00 00 00 00  
00474F  2  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
004753  2  00 00 00 00  
004757  2  00 00 00 00  
00475F  2  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
004763  2  00 00 00 00  
004767  2  00 00 00 00  
00476F  2  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
004773  2  00 00 00 00  
004777  2  00 00 00 00  
00477F  2  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
004783  2  00 00 00 00  
004787  2  00 00 00 00  
00478F  2  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
004793  2  00 00 00 00  
004797  2  00 00 00 00  
00479F  2  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0047A3  2  00 00 00 00  
0047A7  2  00 00 00 00  
0047AF  2  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0047B3  2  00 00 00 00  
0047B7  2  00 00 00 00  
0047BF  2  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0047C3  2  00 00 00 00  
0047C7  2  00 00 00 00  
0047CF  2  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0047D3  2  00 00 00 00  
0047D7  2  00 00 00 00  
0047DF  2  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0047E3  2  00 00 00 00  
0047E7  2  00 00 00 00  
0047EF  2  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0047F3  2  00 00 00 00  
0047F7  2  00 00 00 00  
0047FF  2  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
004803  2  00 00 00 00  
004807  2  00 00 00 00  
00480F  2  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
004813  2  00 00 00 00  
004817  2  00 00 00 00  
00481F  2               
00481F  2               WG_SCRATCHA:
00481F  2  00           .byte 0
004820  2               
004820  2               
004820  2               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
004820  2               ; Lookup tables
004820  2               ;
004820  2               
004820  2               ; Video memory
004820  2               TEXTLINES_H:
004820  2  04           .byte	$04	;0
004821  2  04           .byte	$04	;1
004822  2  05           .byte	$05	;2
004823  2  05           .byte	$05	;3
004824  2  06           .byte	$06	;4
004825  2  06           .byte	$06	;5
004826  2  07           .byte	$07	;6
004827  2  07           .byte	$07	;7
004828  2  04           .byte	$04	;8
004829  2  04           .byte	$04	;9
00482A  2  05           .byte	$05	;10
00482B  2  05           .byte	$05	;11
00482C  2  06           .byte	$06	;12
00482D  2  06           .byte	$06	;13
00482E  2  07           .byte	$07	;14
00482F  2  07           .byte	$07	;15
004830  2  04           .byte	$04	;16
004831  2  04           .byte	$04	;17
004832  2  05           .byte	$05	;18
004833  2  05           .byte	$05	;19
004834  2  06           .byte	$06	;20
004835  2  06           .byte	$06	;21
004836  2  07           .byte	$07	;22
004837  2  07           .byte	$07	;23
004838  2               
004838  2               TEXTLINES_L:
004838  2  00           .byte	$00	;0
004839  2  80           .byte	$80	;1
00483A  2  00           .byte	$00	;2
00483B  2  80           .byte	$80	;3
00483C  2  00           .byte	$00	;4
00483D  2  80           .byte	$80	;5
00483E  2  00           .byte	$00	;6
00483F  2  80           .byte	$80	;7
004840  2  28           .byte	$28	;8
004841  2  A8           .byte	$a8	;9
004842  2  28           .byte	$28	;10
004843  2  A8           .byte	$a8	;11
004844  2  28           .byte	$28	;12
004845  2  A8           .byte	$a8	;13
004846  2  28           .byte	$28	;14
004847  2  A8           .byte	$a8	;15
004848  2  50           .byte	$50	;16
004849  2  D0           .byte	$d0	;17
00484A  2  50           .byte	$50	;18
00484B  2  D0           .byte	$d0	;19
00484C  2  50           .byte	$50	;20
00484D  2  D0           .byte	$d0	;21
00484E  2  50           .byte	$50	;22
00484F  2  D0           .byte	$d0	;23
004850  2               
004850  1               
004850  1               
004850  1               testView:
004850  1  30 30 30 37  	.byte "0007033e13207e"	; 0, 7,3,62,19,126,126
004854  1  30 33 33 65  
004858  1  31 33 32 30  
00485E  1               
00485E  1               testStr:
00485E  1  54 68 69 73  	.byte "This is a test of the emergency broadcast system.",0; If this had been a real emergency, you would be dead now.",0	; 107 chars
004862  1  20 69 73 20  
004866  1  61 20 74 65  
004890  1               
004890  1               
004890  1               
004890  1               
